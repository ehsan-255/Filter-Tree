#!/usr/bin/env node
// packages/cli/src/index.ts
// CLI entry point for ftree

import { Command } from 'commander';
import { writeFile } from 'fs/promises';
import { findConfigFile, loadConfig, getPreset, listPresets } from './config.js';
import { scanFiles } from './scanner.js';
import { buildTree, format, countItems } from './formatter.js';
import type { OutputFormat } from './types.js';

const program = new Command();

program.name('ftree').description('Config-driven filtered file-tree generator').version('0.1.0');

// Run a preset
program
  .command('run <preset>')
  .description('Run a named preset from ftree.yaml')
  .option('-c, --config <path>', 'Path to config file')
  .option('-o, --output <format>', 'Output format: markdown|ascii|json|paths', 'markdown')
  .option('-d, --dir <path>', 'Directory to scan (default: current)')
  .option('--size', 'Show file sizes', true)
  .option('--no-size', 'Hide file sizes')
  .option('--date', 'Show modification dates')
  .option('--no-date', 'Hide modification dates')
  .option('--save <file>', 'Save output to file')
  .action(async (presetName: string, options) => {
    try {
      const workDir = options.dir ?? process.cwd();
      const configPath = options.config ?? (await findConfigFile(workDir));

      if (!configPath) {
        console.error('‚ùå No ftree.yaml found. Run `ftree init` to create one.');
        process.exit(1);
      }

      const config = await loadConfig(configPath);
      const preset = getPreset(config, presetName);

      if (!preset) {
        const available = listPresets(config).join(', ');
        console.error(`‚ùå Preset "${presetName}" not found.\nAvailable: ${available}`);
        process.exit(1);
      }

      const files = await scanFiles(workDir, preset);
      const tree = buildTree(files);
      const counts = countItems(tree);
      const outputFormat = (options.output ?? preset.output ?? 'markdown') as OutputFormat;

      const output = format(tree, files, outputFormat, {
        showSize: options.size ?? preset.showSize ?? true,
        showDate: options.date ?? preset.showDate ?? false,
      });

      // Build header
      const header = `## üå≤ Filter: \`${presetName}\` (${counts.files} files, ${counts.directories} dirs)\n`;
      const footer = `\n> Generated by ftree`;

      let result: string;
      if (outputFormat === 'json') {
        result = output;
      } else if (outputFormat === 'paths') {
        result = output;
      } else {
        result = `${header}\n\`\`\`\n${output}\n\`\`\`${footer}`;
      }

      if (options.save) {
        await writeFile(options.save, result, 'utf-8');
        console.log(`‚úÖ Saved to ${options.save}`);
      } else {
        console.log(result);
      }
    } catch (error) {
      console.error('‚ùå Error:', error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

// List available presets
program
  .command('list')
  .alias('ls')
  .description('List available presets')
  .option('-c, --config <path>', 'Path to config file')
  .action(async (options) => {
    try {
      const configPath = options.config ?? (await findConfigFile(process.cwd()));

      if (!configPath) {
        console.error('‚ùå No ftree.yaml found. Run `ftree init` to create one.');
        process.exit(1);
      }

      const config = await loadConfig(configPath);

      console.log('\nüìã Available presets:\n');
      for (const [name, preset] of Object.entries(config.presets)) {
        const desc = preset.description ? ` - ${preset.description}` : '';
        console.log(`  ‚Ä¢ ${name}${desc}`);
      }

      if (config.aliases && Object.keys(config.aliases).length > 0) {
        console.log('\nüìé Aliases:');
        for (const name of Object.keys(config.aliases)) {
          console.log(`  ‚Ä¢ ${name}`);
        }
      }
      console.log('');
    } catch (error) {
      console.error('‚ùå Error:', error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

// Initialize a new config
program
  .command('init')
  .description('Create a starter ftree.yaml in current directory')
  .option('-f, --force', 'Overwrite existing config')
  .action(async (options) => {
    try {
      const existing = await findConfigFile(process.cwd());
      if (existing && !options.force) {
        console.error(`‚ùå Config already exists: ${existing}`);
        console.error('Use --force to overwrite.');
        process.exit(1);
      }

      const template = `# ftree.yaml - Filter Tree Configuration
# Docs: https://github.com/yourname/ftree

version: "1.0"

# Global defaults applied to all presets
defaults:
  depth: 5
  output: markdown
  showSize: true
  showDate: false
  exclude:
    - "**/node_modules/**"
    - "**/.git/**"
    - "**/dist/**"
    - "**/build/**"

# Named presets for different use cases
presets:
  # Recently modified documentation
  recent-docs:
    description: "Documentation modified in the last 7 days"
    extensions: [md, mdx, txt, rst]
    modifiedWithin: 7d
    depth: 4

  # Source code files
  source:
    description: "Source code files"
    extensions: [ts, tsx, js, jsx, py, go, rs]
    exclude:
      - "**/test/**"
      - "**/*.test.*"
      - "**/*.spec.*"

  # Large files that might need cleanup
  large-files:
    description: "Files larger than 1MB"
    minSize: 1MB
    sortBy: size-desc

  # Config files across the project
  configs:
    description: "Configuration files"
    patterns:
      - "**/.*rc"
      - "**/.*rc.{js,json,yaml,yml}"
      - "**/*.config.{js,ts,mjs}"
      - "**/tsconfig*.json"
      - "**/package.json"

  # Assets and media
  assets:
    description: "Images and media files"
    extensions: [png, jpg, jpeg, gif, svg, webp, mp4, webm]
    depth: 3

  # All README files
  readmes:
    description: "All README.md files across the project"
    patterns:
      - "**/README.md"
      - "**/README"
      - "**/readme.md"
    depth: 10

  # AI agent documentation files
  ai-docs:
    description: "AI agent-facing documentation (AGENTS, CLAUDE, GEMINI)"
    patterns:
      - "**/AGENTS.md"
      - "**/CLAUDE.md"
      - "**/GEMINI.md"
      - "**/COPILOT.md"
      - "**/.github/copilot-instructions.md"
    depth: 10

# Quick aliases for common filters
aliases:
  ts: { extensions: [ts, tsx] }
  js: { extensions: [js, jsx, mjs] }
  styles: { extensions: [css, scss, sass, less] }
  docs: { extensions: [md, mdx, txt] }
`;

      await writeFile('ftree.yaml', template, 'utf-8');
      console.log('‚úÖ Created ftree.yaml');
      console.log('\nTry running:');
      console.log('  ftree list        # See available presets');
      console.log('  ftree run source  # Run a preset');
    } catch (error) {
      console.error('‚ùå Error:', error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

// Quick filter (ad-hoc, no config needed)
program
  .command('quick')
  .alias('q')
  .description('Quick filter without config file')
  .option('-e, --ext <extensions>', 'File extensions (comma-separated)', '')
  .option('-d, --depth <n>', 'Max depth', '5')
  .option('--min-size <size>', 'Minimum file size (e.g., 1KB, 500MB)')
  .option('--max-size <size>', 'Maximum file size')
  .option('--since <duration>', 'Modified within (e.g., 7d, 2h)')
  .option('-o, --output <format>', 'Output format', 'markdown')
  .option('--dirs-only', 'Show only directories')
  .option('--files-only', 'Show only files')
  .action(async (options) => {
    try {
      const preset: Record<string, unknown> = {
        depth: parseInt(options.depth),
        output: options.output,
      };

      if (options.ext) {
        preset.extensions = options.ext.split(',').map((e: string) => e.trim());
      }
      if (options.minSize) preset.minSize = options.minSize;
      if (options.maxSize) preset.maxSize = options.maxSize;
      if (options.since) preset.modifiedWithin = options.since;
      if (options.dirsOnly) preset.type = 'directory';
      if (options.filesOnly) preset.type = 'file';

      const files = await scanFiles(process.cwd(), preset);
      const tree = buildTree(files);
      const counts = countItems(tree);
      const output = format(tree, files, options.output, { showSize: true });

      console.log(`\n## üå≤ Quick Filter (${counts.files} files, ${counts.directories} dirs)\n`);
      console.log('```');
      console.log(output);
      console.log('```');
    } catch (error) {
      console.error('‚ùå Error:', error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

program.parse();
